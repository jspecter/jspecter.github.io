(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{414:function(e,t,r){"use strict";r.r(t);var n=r(7),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("ol",[r("li",[r("p",[r("strong",[e._v("hasOwnProperty方法：")]),e._v("\n所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。")])]),e._v(" "),r("li",[r("p",[e._v("** Object.assign 与 ... 比较 **")]),e._v(" "),r("blockquote",[r("p",[e._v("The spread operator and Object.assign() are very similar. The main difference is that spreading defines new properties, while Object.assign() sets them")])]),e._v(" "),r("p",[e._v("一言以蔽之，Object.assign会通过setter来修改对象属性，且会污染对象原型属性；而对象展开符只是单纯的copy对象，会通过类似defineProperty来在对象上定义一个新的属性，而不会侵入对象原型。\n"),r("a",{attrs:{href:"https://2ality.com/2016/10/rest-spread-properties.html#spread-defines-properties-objectassign-sets-them",target:"_blank",rel:"noopener noreferrer"}},[e._v("详情参考"),r("OutboundLink")],1)])]),e._v(" "),r("li",[r("p",[e._v("Object.assign的android及ios低版本兼容问题：")]),e._v(" "),r("ul",[r("li",[e._v("将Object.assign替换为对象展开符...")]),e._v(" "),r("li",[e._v("使用npm包"),r("a",{attrs:{href:"https://www.npmjs.com/package/object.assign",target:"_blank",rel:"noopener noreferrer"}},[e._v("object.assign"),r("OutboundLink")],1),e._v(" 或者 "),r("a",{attrs:{href:"https://www.npmjs.com/package/object-assign",target:"_blank",rel:"noopener noreferrer"}},[e._v("object-assign"),r("OutboundLink")],1),e._v("来做polyfill")]),e._v(" "),r("li",[e._v("使用babel插件"),r("a",{attrs:{href:"https://babeljs.io/docs/en/babel-plugin-transform-object-assign",target:"_blank",rel:"noopener noreferrer"}},[e._v("@babel/plugin-transform-object-assign"),r("OutboundLink")],1),e._v("来做转义")])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);